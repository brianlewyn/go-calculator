// Code generated by version 3.5.0 of the Linked List Library from github.com/brianlewyn/go-linked-list/v3

// Copyright (c) 2023, Brayan Mejía. All rights reserved.
// Use of this source code is governed by a MIT
// license that can be found in the LICENSE file.

package doubly

import (
	"fmt"
	"strings"

	"github.com/brianlewyn/go-calculator/internal/data"
)

// Doubly represents the Doubly Linked List.
type Doubly struct {
	head *Node
	tail *Node
	size int
}

// Todo: Instance Functions

// New returns a new instance of Doubly.
func New() *Doubly {
	return iNew()
}

// Todo: Getting Methods

// Size returns the number of nodes in the list.
func (d Doubly) Size() int {
	return d.size
}

// Head returns the first node in the list,
// but if the list is empty returns nil.
func (d Doubly) Head() *Node {
	return d.head
}

// Tail returns the last node in the list,
// but if the list is empty returns nil.
func (d Doubly) Tail() *Node {
	return d.tail
}

// String returns a string representation of the list.
func (d Doubly) String() string {
	return d.toString()
}

// Todo: Pushing Methods

// PushNodeForwardFrom inserts a node at the specified index,
// starting from a given node in the forward direction,
// It returns true if the insertion is successful, or false if the index is out of range.
func (d *Doubly) PushNodeForwardFrom(from *Node, index int, node *Node) bool {
	return d.pushNodeForwardFrom(from, index, node)
}

// PushFront adds a new node with the specified data at the front of the list.
func (d *Doubly) PushFront(data data.Token) {
	d.pushHead(iNode(data))
}

// PushBack adds a new node with the specified data at the end of the list.
func (d *Doubly) PushBack(data data.Token) {
	d.pushTail(iNode(data))
}

// Todo: Removing Methods

// RemoveHead removes the head node from the doubly linked list.
// Returns true if the head node is successfully removed, false otherwise.
func (d *Doubly) RemoveHead() bool {
	return d.removeHead()
}

// RemoveNode removes the specified node from the doubly linked list.
// Returns true if the node is successfully removed, false otherwise.
func (d *Doubly) RemoveNode(node *Node) bool {
	return d.removeNode(node)
}

// Todo: Question Methods

// IsEmpty checks if the doubly linked list is empty.
// Returns true if the list is empty, false otherwise.
func (d Doubly) IsEmpty() bool {
	return d.isEmpty()
}

// Todo: Connection Methods

// ConnectAfterNode connects the 'want' node after the 'got' node in the doubly linked list.
// If the list is empty, it initializes the list with the 'want' node.
func (d *Doubly) ConnectAfterNode(got, want *Node) {
	d.connectNodeAfterFrom(got, want)
}

// !Tool Functions

// initializations

func iNew() *Doubly {
	return &Doubly{}
}

// !Tool Methods

// gettings

func (d Doubly) nodeByIndexForwardFrom(from *Node, index *int) *Node {
	for current := from; current != nil; *index, current = *index-1, current.next {
		if *index == 0 {
			return current
		}
	}
	*index++
	return nil
}

func (d Doubly) toString() string {
	var builder strings.Builder

	for temp := d.head; temp != nil; temp = temp.next {
		fmt.Fprintf(&builder, "%+v ⇒ ", temp.token)
	}

	return builder.String()
}

// initializations

func (d *Doubly) init() {
	d.head = nil
	d.tail = nil
	d.size = 0
}

func (d *Doubly) initHead(node *Node) {
	d.head = node
	d.head.prev = nil
}

func (d *Doubly) initTail(node *Node) {
	d.tail = node
	d.tail.next = nil
}

func (d *Doubly) initNode(node *Node) {
	node.RemoveNode()
	d.head = node
	d.tail = node
	d.size = 1
}

// addings

func (d *Doubly) addNewHead(node *Node) {
	node.connect(d.head)
	d.initHead(node)
	d.size++
}

func (d *Doubly) addNewTail(node *Node) {
	d.tail.connect(node)
	d.initTail(node)
	d.size++
}

func (d *Doubly) addNodeBeforeFrom(from *Node, node *Node) {
	from.prev.connect(node)
	node.connect(from)
	d.size++
}

// pushings

func (d *Doubly) pushHead(node *Node) {
	if d.isEmpty() {
		d.initNode(node)
	} else {
		d.addNewHead(node)
	}
}

func (d *Doubly) pushTail(node *Node) {
	if d.isEmpty() {
		d.initNode(node)
	} else {
		d.addNewTail(node)
	}
}

func (d *Doubly) pushNodeForwardFrom(from *Node, index int, node *Node) bool {
	temp := d.nodeByIndexForwardFrom(from, &index)

	if d.isHead(temp) {
		d.addNewHead(node)
		return true
	}

	if index == 1 {
		d.addNewTail(node)
		return true
	}

	if temp == nil {
		return false
	}

	d.addNodeBeforeFrom(temp, node)
	return true
}

// deletings

func (d *Doubly) deleteHead() {
	head := d.head
	d.initHead(d.head.next)
	head.next = nil
	d.size--
}

func (d *Doubly) deleteTail() {
	tail := d.tail
	d.initTail(d.tail.prev)
	tail.prev = nil
	d.size--
}

func (d *Doubly) deleteNode(node *Node) {
	node.prev.connect(node.next)
	node.RemoveNode()
	d.size--
}

// removings

func (d *Doubly) removeHead() bool {
	if d.isEmpty() {
		return false
	}

	if d.size == 1 {
		d.init()
		return true
	}

	d.deleteHead()
	return true
}

func (d *Doubly) removeNode(node *Node) bool {
	if d.isEmpty() || node == nil {
		return false
	}

	if d.size == 1 {
		d.init()
		return true
	}

	if d.isHead(node) {
		d.removeHead()
		return true
	}

	if d.isTail(node) {
		d.deleteTail()
		return true
	}

	d.deleteNode(node)
	return true
}

// questions

func (d Doubly) isEmpty() bool {
	return d.head == nil && d.tail == nil
}

func (d Doubly) isHead(node *Node) bool {
	return node == d.head
}

func (d Doubly) isTail(node *Node) bool {
	return node == d.tail
}

// unions

func (d *Doubly) unionNodeAfterHead(node *Node) {
	node.connect(d.head.next)
	d.head.connect(node)
	d.size++
}

func (d *Doubly) unionNodeAfterFrom(from, node *Node) {
	node.connect(from.next)
	from.connect(node)
	d.size++
}

// connetions

func (d *Doubly) connectNodeAfterFrom(from, node *Node) {
	if d.isEmpty() {
		d.initNode(node)
		return
	}

	if d.isTail(from) {
		d.addNewTail(node)
		return
	}

	if d.isHead(from) {
		d.unionNodeAfterHead(node)
		return
	}

	d.unionNodeAfterFrom(from, node)
}
